(window.webpackJsonp=window.webpackJsonp||[]).push([[168],{765:function(e,t,o){"use strict";o.r(t);var s=o(2),a=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("One of the big ideas that makes Rollux possible is the optimistic rollup.\nWe'll go through a brief explainer of "),t("em",[e._v("how")]),e._v(" optimistic rollups work at a high level.\nThen we'll explain "),t("em",[e._v("how")]),e._v(" Rollux is built as an optimistic rollup and why we believe it's the best option for a system that addresses all of our design goals.")]),e._v(" "),t("h2",{attrs:{id:"optimistic-rollups-tl-dr"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#optimistic-rollups-tl-dr"}},[e._v("#")]),e._v(" optimistic rollups TL;DR")]),e._v(" "),t("p",[e._v('Rollux is an "optimistic rollup," which is basically just a fancy way of describing a blockchain that piggy-backs off of the security of another "parent" blockchain.\nSpecifically, optimistic rollups take advantage of the consensus mechanism (like PoW or PoS) of their parent chain instead of providing their own.\nIn Rollux\'s case this parent blockchain is Syscoin. That means Rollux inherits the upstream security of Syscoin, which is merge-mined by the most powerful PoW network on the planet, Bitcoin! Furthermore, Syscoin L1 provides decentralized finality on top of Nakamoto consensus which makes it highly resistant to 51% attacks, and Syscoin provides data availability with PoDA. You can find out more about Syscoin and what makes it special '),t("RouterLink",{attrs:{to:"/docs/sys/"}},[e._v("here")]),e._v("!")],1),e._v(" "),t("h2",{attrs:{id:"block-storage"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#block-storage"}},[e._v("#")]),e._v(" Block storage")]),e._v(" "),t("details",{attrs:{open:""}},[t("summary",[t("b",[e._v("Syscoin L1 Data Availability for Rollux")])]),e._v("\nUnlike Optimism which must expensively store blocks on the Ethereum L1 as calldata, Rollux L2 blocks are stored via Syscoin's Layer 1 PoDA protocol (Proof-of-Data-Availability). A proof of the block is stored on Syscoin's native (UTXO) blockchain, and the entirety of the raw block data is stored in the cloud via Syscoin full nodes that also function as PoDA cloud clients.\n"),t("p",[e._v("Refer to "),t("RouterLink",{attrs:{to:"/docs/sys/PoDA.html"}},[e._v("PoDA")]),e._v(" for a high level understanding of Syscoin PoDA and its benefits.")],1),e._v(" "),t("p",[e._v("In brief, PoDA already provides a number of benefits over Ethereum's work-in-progress and future DA solution (proto-danksharding):")]),e._v(" "),t("ol",[t("li",[e._v("PoDA does not need to shard data. Every full node processes blobs fully.\n"),t("ul",[t("li",[e._v("Trust yourself only")]),e._v(" "),t("li",[e._v("Fewer attack vectors, more resistant to censorship")]),e._v(" "),t("li",[e._v("Data is simple to reproduce and check")]),e._v(" "),t("li",[e._v("Syscoin can prune data much quicker, and tie in pruning with finality + 6 hours.")])])]),e._v(" "),t("li",[e._v("PoDA uses Keccak-based blobs instead of KZG commitments.\n"),t("ul",[t("li",[e._v("No trusted setup")]),e._v(" "),t("li",[e._v("Quantum safe")]),e._v(" "),t("li",[e._v("Very performant")])])])]),e._v(" "),t("p",[e._v("Go compare Rollux's and Optimism's approaches to data availability firsthand by viewing this Github commit: "),t("a",{attrs:{href:"https://github.com/sys-labs/rollux/commit/25a4c9410ddae31ff7195f67495491f71e684e03",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/sys-labs/rollux/commit/25a4c9410ddae31ff7195f67495491f71e684e03"),t("OutboundLink")],1),e._v(". You can also view the full diff here: "),t("a",{attrs:{href:"https://github.com/ethereum-optimism/optimism/compare/develop...sys-labs:rollux:develop",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/ethereum-optimism/optimism/compare/develop...sys-labs:rollux:develop"),t("OutboundLink")],1),e._v(".")])]),e._v(" "),t("details",{attrs:{open:""}},[t("summary",[t("b",[e._v("Rollux L2 Data Availability for supporting L3 and beyond (fractal scaling)")])]),e._v(" "),t("p",[e._v("Another key differentiator in Rollux's favor is that it is already primed to support L3s and fractal scaling with proper data availability. This is because Rollux offers its own implementation of PoDA natively. This means other layers can use Rollux for data availability. Rollux PoDA handles data storage in a similar manner as Syscoin, with the added benefits of more throughput and even lower costs. Fractal layers using Rollux also inherit the security of Syscoin's L1, as Rollux stores its own block data there.")])]),e._v(" "),t("h2",{attrs:{id:"block-production"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#block-production"}},[e._v("#")]),e._v(" Block production")]),e._v(" "),t("p",[e._v('Rollux block production at present is primarily managed by a single party, called the "sequencer," which helps the network by providing the following services:')]),e._v(" "),t("ul",[t("li",[e._v("Providing transaction confirmations and state updates.")]),e._v(" "),t("li",[e._v("Constructing and executing L2 blocks.")]),e._v(" "),t("li",[e._v("Submitting user transactions to L1.")])]),e._v(" "),t("p",[e._v("The sequencer does have a mempool, similar to Syscoin NEVM or Ethereum, but the mempool is private to avoid opening opportunities for MEV. Blocks are produced every two seconds, regardless of whether they are empty (no transactions), filled up to the block gas limit with transactions, or anything in between.")]),e._v(" "),t("p",[e._v("Transactions get to the sequencer in two ways:")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("Transactions submitted on L1 (called "),t("em",[e._v("deposits")]),e._v(' whether they have assets attached or not) are included in the chain in the appropriate L2 block.\nEvery L2 block is identified by the "epoch" (the L1 block to which it corresponds, which typically has happened a few minutes before the L2 block) and its serial number within that epoch.\nThe first block of the epoch includes all the deposits that happened in the L1 block to which it corresponds.\nIf the sequencer attempts to ignore a legitimate L1 transaction it ends up with a state that is inconsistent with the verifiers, same as if the sequencer tried to fake the state by other means.\nThis provides Rollux with L1 Syscoin level censorship resistance.\nYou can read more about this mechanism '),t("a",{attrs:{href:"https://github.com/sys-labs/rollux/blob/develop/specs/derivation.md#deriving-the-transaction-list",target:"_blank",rel:"noopener noreferrer"}},[e._v("is the protocol specifications"),t("OutboundLink")],1),e._v(".")])]),e._v(" "),t("li",[t("p",[e._v("Transactions submitted directly to the sequnecer.\nThese transactions are a lot cheaper to submit (because you do not need the expense of a separate L1 transaction), but of course they cannot be made censorship resistant, because the sequencer is the only entity that knows about them.")])])]),e._v(" "),t("p",[e._v("For the moment, the non-profit Syscoin Foundation runs the only block producer. Refer to "),t("RouterLink",{attrs:{to:"/docs/protocol/"}},[e._v("Protocol specs")]),e._v(" section for more information about how we plan to decentralize the Sequencer role in the future.")],1),e._v(" "),t("h2",{attrs:{id:"block-execution"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#block-execution"}},[e._v("#")]),e._v(" Block execution")]),e._v(" "),t("p",[e._v("The execution engine (implemented as the "),t("code",[e._v("op-geth")]),e._v(" component) receive blocks using two mechanisms:")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("The execution engine can update itself using peer to peer network with other execution engines.\nThis operates the same way that the L1 execution clients synchronize the state across the network.\nYou can read more about it "),t("a",{attrs:{href:"https://github.com/sys-labs/rollux/blob/develop/specs/exec-engine.md#happy-path-sync",target:"_blank",rel:"noopener noreferrer"}},[e._v("in the specs"),t("OutboundLink")],1),e._v(".")])]),e._v(" "),t("li",[t("p",[e._v("The rollup node (implemented as the "),t("code",[e._v("op-node")]),e._v(" component) derives the L2 blocks from L1.\nThis mechanism is slower, but censorship resistant.\nYou can read more about it "),t("a",{attrs:{href:"https://github.com/sys-labs/rollux/blob/develop/specs/exec-engine.md#worst-case-sync",target:"_blank",rel:"noopener noreferrer"}},[e._v("in the specs"),t("OutboundLink")],1),e._v(".")])])]),e._v(" "),t("h2",{attrs:{id:"bridging-assets-between-layers"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bridging-assets-between-layers"}},[e._v("#")]),e._v(" Bridging assets between layers")]),e._v(" "),t("p",[e._v("Rollux is designed so that users can send arbitrary messages between smart contracts on Rollux and Syscoin.\nThis makes it possible to transfer assets, including ERC20 tokens, between the two networks.\nThe exact mechanism by which this communication occurs differs depending on the direction in which messages are being sent.")]),e._v(" "),t("p",[e._v("Rollux uses this functionality in the Standard bridge to allow users to deposit assets (ERC20s and SYS) from Syscoin to Rollux and also allow withdrawals of the same from Rollux back to Syscoin.\nSee the "),t("RouterLink",{attrs:{to:"/docs/developers/bridge/standard-bridge/"}},[e._v("developer documentation and examples")]),e._v(" on details on the inner workings of the Standard bridge.")],1),e._v(" "),t("h3",{attrs:{id:"moving-from-syscoin-to-rollux"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#moving-from-syscoin-to-rollux"}},[e._v("#")]),e._v(" Moving from Syscoin to Rollux")]),e._v(" "),t("p",[e._v("In Rollux terminology, transactions going from Syscoin (L1) to Rollux (L2) are called "),t("em",[e._v("deposits")]),e._v(", even if they do not have any assets attached to them.")]),e._v(" "),t("p",[e._v("The contract interface for deposits is very similar, you use "),t("a",{attrs:{href:"https://github.com/sys-labs/rollux-tutorial/tree/main/cross-dom-comm",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("L1CrossDomainMessenger")]),t("OutboundLink")],1),e._v(" or "),t("a",{attrs:{href:"https://github.com/sys-labs/rollux/blob/develop/packages/contracts-bedrock/contracts/L1/L1StandardBridge.sol",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("L1StandardBridge")]),t("OutboundLink")],1),e._v('.\nDeposit transactions become part of the canonical blockchain in the first L2 block of the "epoch" corresponding to the L1 block where the deposits were made.\nThis L2 block will usually be created a few minutes after the corresponding L1 block.\nYou can read more about this '),t("a",{attrs:{href:"https://github.com/sys-labs/rollux/blob/develop/specs/deposits.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("in the specs"),t("OutboundLink")],1),e._v(".")]),e._v(" "),t("h3",{attrs:{id:"moving-from-rollux-to-syscoin"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#moving-from-rollux-to-syscoin"}},[e._v("#")]),e._v(" Moving from Rollux to Syscoin")]),e._v(" "),t("p",[e._v("Withdrawals (the term is used for any Rollux to Syscoin message, regardless of whether it has attached assets or not) have three stages:")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("You initialize withdrawals with an L2 transaction.")])]),e._v(" "),t("li",[t("p",[e._v("Wait for the next output root to be submitted to L1 (you can see this on "),t("RouterLink",{attrs:{to:"/docs/sdk/js-client.html"}},[e._v("the SDK")]),e._v(") and then submit the withdrawal proof using "),t("code",[e._v("proveWithdrawalTransaction")]),e._v(".\nThis new step enables off-chain monitoring of the withdrawals, which makes it easier to identify incorrect withdrawals or output roots.\nThis protects Rollux users against a whole class of potential bridge vulnerabilities.")],1)]),e._v(" "),t("li",[t("p",[e._v("After the fault challenge period ends (a week on mainnet, less than that on the test network), finalize the withdrawal.")])])]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/sys-labs/rollux/blob/develop/specs/withdrawals.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("You can read the full withdrawal specifications here"),t("OutboundLink")],1)]),e._v(" "),t("h2",{attrs:{id:"fault-proofs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fault-proofs"}},[e._v("#")]),e._v(" Fault proofs")]),e._v(" "),t("p",[e._v('In an optimistic rollup, state commitments are published to Syscoin without any direct proof of the validity of these commitments.\nInstead, these commitments are considered pending for a period of time (called the "challenge window").\nIf a proposed state commitment goes unchallenged for the duration of the challenge window (currently set to 7 days), then it is considered final.\nOnce a commitment is considered final, smart contracts on Syscoin can safely accept withdrawal proofs about the state of Rollux based on that commitment.')]),e._v(" "),t("p",[e._v('When a state commitment is challenged, it can be invalidated through a "fault proof" ('),t("a",{attrs:{href:"https://github.com/ethereum-optimism/optimistic-specs/discussions/53",target:"_blank",rel:"noopener noreferrer"}},[e._v('formerly known as a "fraud proof"'),t("OutboundLink")],1),e._v(") process.\nIf the commitment is successfully challenged, then it is removed from the "),t("code",[e._v("StateCommitmentChain")]),e._v(" to eventually be replaced by another proposed commitment.\nIt's important to note that a successful challenge does not roll back Rollux itself, only the published commitments about the state of the chain.\nThe ordering of transactions and the state of Rollux is unchanged by a fault proof challenge.")]),e._v(" "),t("p",[e._v("The fault proof process is currently undergoing major redevelopment as a side-effect of the EVM-equivalence update.\nYou can read more about this process within the "),t("RouterLink",{attrs:{to:"/docs/protocol/"}},[e._v("Protocol specs")]),e._v(" section of this website.")],1)])}),[],!1,null,null,null);t.default=a.exports}}]);