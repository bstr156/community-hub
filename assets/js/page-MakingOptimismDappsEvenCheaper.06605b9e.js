(window.webpackJsonp=window.webpackJsonp||[]).push([[150],{783:function(e,t,a){"use strict";a.r(t);var o=a(2),r=Object(o.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("The cost of using a decentralized application in Optimism is much lower than the cost of the equivalent application on L1 Ethereum.\n"),t("a",{attrs:{href:"https://l2fees.info/",target:"_blank",rel:"noopener noreferrer"}},[e._v("See here"),t("OutboundLink")],1),e._v(" for the current values.\nHowever, with proper optimization, we can make our decentralized applications even cheaper.\nHere are some strategies.")]),e._v(" "),t("h2",{attrs:{id:"background"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#background"}},[e._v("#")]),e._v(" Background")]),e._v(" "),t("p",[e._v("This is a basic introduction into some of the concepts you need to understand to fully optimise your contracts in the Optimism L2 environment.")]),e._v(" "),t("h3",{attrs:{id:"what-are-the-transaction-fees"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#what-are-the-transaction-fees"}},[e._v("#")]),e._v(" What are the transaction fees?")]),e._v(" "),t("p",[e._v("The cost of an L2 transaction on Optimism is composed of two components:")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("L2 execution fee, which is proportional to the gas actually used in processing the transaction.\nNormally the cost of L2 gas is 0.001 gwei, but this may increase when the system is extremely congested.\nDo not hardcode this value.")])]),e._v(" "),t("li",[t("p",[e._v("L1 data fee, which is proportional to:")]),e._v(" "),t("ul",[t("li",[e._v("The gas cost of writing the transaction's data to L1 (roughly equal to the transaction's length)")]),e._v(" "),t("li",[e._v("The cost of gas on L1.\nThe cost of gas on L1 can be extremely volatile.")])])])]),e._v(" "),t("p",[e._v("To view the current gas costs as a user, "),t("a",{attrs:{href:"https://public-grafana.optimism.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("see here"),t("OutboundLink")],1),e._v(". To retrieve them programatically, "),t("a",{attrs:{href:"https://github.com/ethereum-optimism/optimism-tutorial/tree/main/sdk-estimate-gas",target:"_blank",rel:"noopener noreferrer"}},[e._v("see here"),t("OutboundLink")],1),e._v(".")]),e._v(" "),t("p",[e._v("For a more in depth look at how transaction fees are calculated see our "),t("RouterLink",{attrs:{to:"/docs/rollux-developers/build/transaction-fees.html"}},[e._v("fee documentation")]),e._v(".")],1),e._v(" "),t("h3",{attrs:{id:"optimization-tradeoffs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#optimization-tradeoffs"}},[e._v("#")]),e._v(" Optimization tradeoffs")]),e._v(" "),t("p",[e._v("In almost all cases, the L1 data fee is the vast majority of the transaction's cost.\nThe L2 execution fee is, comparatively speaking, negligible.\nThis means that the optimization tradeoffs are very different in Optimism than they are in Ethereum.")]),e._v(" "),t("p",[e._v("Transaction call data is "),t("em",[e._v("expensive")]),e._v(".\nThe cost of writing a byte to L1 is approximately 16 gas.\nAt a cost of 45 gwei per L1 gas unit, writing one byte to L1 on Optimism costs 720 gwei, or 720,000 units of L2 gas (at the non-congested price of 0.001 gwei per L2 gas unit).")]),e._v(" "),t("p",[e._v("In comparison, onchain processing and storage are cheap.\nThe worst case for writing to storage (previously uninitialized storage) is a cost of "),t("a",{attrs:{href:"https://www.evm.codes/#55",target:"_blank",rel:"noopener noreferrer"}},[e._v("22100 L2 gas per EVM word, which contains 32 bytes of data"),t("OutboundLink")],1),e._v(", which averages out to less than 700 L2 gas / byte.\nAt a cost of 45 gwei per L1 gas unit, this means it is cheaper to write a whole kilobyte to storage, rather than add one byte to the transaction call data.")]),e._v(" "),t("h2",{attrs:{id:"modify-the-abi-application-binary-interface"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#modify-the-abi-application-binary-interface"}},[e._v("#")]),e._v(" Modify the "),t("a",{attrs:{href:"https://docs.soliditylang.org/en/latest/abi-spec.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("ABI (application binary interface)"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"https://docs.soliditylang.org/en/latest/abi-spec.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("The standard ABI"),t("OutboundLink")],1),e._v(" was designed with L1 tradeoffs in mind.\nIt uses four byte function selectors and pads values to a 32 byte size.\nNeither is optimal when using Optimism.")]),e._v(" "),t("p",[e._v("It is much more efficient to "),t("a",{attrs:{href:"https://ethereum.org/en/developers/tutorials/short-abi/",target:"_blank",rel:"noopener noreferrer"}},[e._v("create a shorter ABI with just the required bytes, and decode it onchain"),t("OutboundLink")],1),e._v(".\nAll of your "),t("a",{attrs:{href:"https://docs.soliditylang.org/en/latest/contracts.html#view-functions",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("view")]),t("OutboundLink")],1),e._v(" and "),t("a",{attrs:{href:"https://docs.soliditylang.org/en/latest/contracts.html#pure-functions",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("pure")]),t("OutboundLink")],1),e._v(" functions can use the standard ABI at no cost.")]),e._v(" "),t("h2",{attrs:{id:"use-smaller-values-when-possible"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#use-smaller-values-when-possible"}},[e._v("#")]),e._v(" Use smaller values when possible")]),e._v(" "),t("p",[e._v("Your modified ABI is not going to pad values, so the less bytes you use the better.\nFor example, it is standard to use "),t("code",[e._v("uint256")]),e._v(" for amounts.\nThis means that the highest number we can represent is 2"),t("sup",[e._v("256")]),e._v("-1, or about 1.2*10"),t("sup",[e._v("77")]),e._v(".\nWhen storing ETH balances, for example, using "),t("code",[e._v("uint256")]),e._v(" is overkill as there are only "),t("a",{attrs:{href:"https://ycharts.com/indicators/ethereum_supply",target:"_blank",rel:"noopener noreferrer"}},[e._v("120 million ETH"),t("OutboundLink")],1),e._v(". Thus, we can safely store ETH balances in "),t("code",[e._v("uint88")]),e._v(" which is just eleven bytes.")]),e._v(" "),t("p",[e._v("Go through your contracts and identify any values that will never reach 32 bytes and reduce them to logical sizes. You can do this same process for ints, bytes and "),t("a",{attrs:{href:"https://docs.soliditylang.org/en/develop/types.html#types",target:"_blank",rel:"noopener noreferrer"}},[e._v("other Solidity data types"),t("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=r.exports}}]);