(window.webpackJsonp=window.webpackJsonp||[]).push([[151],{690:function(e,t,a){"use strict";a.r(t);var o=a(2),n=Object(o.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("The cost of using a decentralized application in Rollux is much lower than the cost of the equivalent application on L1 Syscoin (and Ethereum even more so).\nHowever, with proper optimization, we can make our decentralized applications even cheaper.\nHere are some strategies.")]),e._v(" "),t("h2",{attrs:{id:"background"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#background"}},[e._v("#")]),e._v(" Background")]),e._v(" "),t("p",[e._v("This is a basic introduction into some of the concepts you need to understand to fully optimise your contracts in the Rollux L2 environment.")]),e._v(" "),t("h3",{attrs:{id:"what-are-the-transaction-fees"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#what-are-the-transaction-fees"}},[e._v("#")]),e._v(" What are the transaction fees?")]),e._v(" "),t("p",[e._v("The cost of an L2 transaction on Rollux is composed of two components:")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("L2 execution fee, which is proportional to the gas actually used in processing the transaction.\nNormally the cost of L2 gas is 0.001 gwei, but this may increase when the system is extremely congested.\nDo not hardcode this value.")])]),e._v(" "),t("li",[t("p",[e._v("L1 data fee, which is proportional to:")]),e._v(" "),t("ul",[t("li",[e._v("The gas cost of settling the transaction's data with PoDA on L1")]),e._v(" "),t("li",[e._v("The cost of gas on L1.\nThe cost of gas on L1 can be somewhat volatile.")])])])]),e._v(" "),t("p",[e._v("To retrieve current gas costs programatically, "),t("a",{attrs:{href:"https://github.com/SYS-Labs/rollux-tutorial/tree/main/sdk-estimate-gas",target:"_blank",rel:"noopener noreferrer"}},[e._v("see here"),t("OutboundLink")],1),e._v(".")]),e._v(" "),t("p",[e._v("For a more in depth look at how transaction fees are calculated see our "),t("RouterLink",{attrs:{to:"/docs/developers/build/transaction-fees.html"}},[e._v("fee documentation")]),e._v(".")],1),e._v(" "),t("h2",{attrs:{id:"modify-the-abi-application-binary-interface"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#modify-the-abi-application-binary-interface"}},[e._v("#")]),e._v(" Modify the "),t("a",{attrs:{href:"https://docs.soliditylang.org/en/latest/abi-spec.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("ABI (application binary interface)"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"https://docs.soliditylang.org/en/latest/abi-spec.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("The standard ABI"),t("OutboundLink")],1),e._v(" was designed with L1 tradeoffs in mind.\nIt uses four byte function selectors and pads values to a 32 byte size.\nNeither is optimal when using Rollux.")]),e._v(" "),t("p",[e._v("It is much more efficient to "),t("a",{attrs:{href:"https://ethereum.org/en/developers/tutorials/short-abi/",target:"_blank",rel:"noopener noreferrer"}},[e._v("create a shorter ABI with just the required bytes, and decode it onchain"),t("OutboundLink")],1),e._v(".\nAll of your "),t("a",{attrs:{href:"https://docs.soliditylang.org/en/latest/contracts.html#view-functions",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("view")]),t("OutboundLink")],1),e._v(" and "),t("a",{attrs:{href:"https://docs.soliditylang.org/en/latest/contracts.html#pure-functions",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("pure")]),t("OutboundLink")],1),e._v(" functions can use the standard ABI at no cost.")]),e._v(" "),t("h2",{attrs:{id:"use-smaller-values-when-possible"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#use-smaller-values-when-possible"}},[e._v("#")]),e._v(" Use smaller values when possible")]),e._v(" "),t("p",[e._v("Your modified ABI is not going to pad values, so the less bytes you use the better.\nFor example, it is standard to use "),t("code",[e._v("uint256")]),e._v(" for amounts.\nThis means that the highest number we can represent is 2"),t("sup",[e._v("256")]),e._v("-1, or about 1.2*10"),t("sup",[e._v("77")]),e._v(".\nWhen storing ETH balances, for example, using "),t("code",[e._v("uint256")]),e._v(" is overkill as there are only "),t("a",{attrs:{href:"https://ycharts.com/indicators/ethereum_supply",target:"_blank",rel:"noopener noreferrer"}},[e._v("120 million ETH"),t("OutboundLink")],1),e._v(". Thus, we can safely store SYS balances in "),t("code",[e._v("uint88")]),e._v(" which is just eleven bytes.")]),e._v(" "),t("p",[e._v("Go through your contracts and identify any values that will never reach 32 bytes and reduce them to logical sizes. You can do this same process for ints, bytes and "),t("a",{attrs:{href:"https://docs.soliditylang.org/en/develop/types.html#types",target:"_blank",rel:"noopener noreferrer"}},[e._v("other Solidity data types"),t("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=n.exports}}]);