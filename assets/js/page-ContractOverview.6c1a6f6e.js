(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{769:function(e,t,a){"use strict";a.r(t);var s=a(2),r=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"introduction"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#introduction"}},[e._v("#")]),e._v(" Introduction")]),e._v(" "),t("p",[e._v("Rollux is a Layer 2 scaling protocol for Syscoin applications. Because Syscoin and Rollux are both EVM-equivalent, any application built for Ethereum can take advantage of Rollux.\nRollux makes transactions cheap. Real cheap. In fact, even cheaper than Optimism on Ethereum.\nWe aim to make transacting on Syscoin affordable and\naccessible to anyone, to the degree that blockchain can actually be mass-adoptable.")]),e._v(" "),t("p",[e._v("This document is intended for anyone looking for a deeper understanding of how the protocol works\n'under the hood'.")]),e._v(" "),t("p",[e._v("Rollux is meant to look, feel and behave like Ethereum or Syscoin, but cheaper and much faster.\nFor developers building on Rollux, we aim to make the transition as seamless as possible.\nWith very few exceptions,\nexisting Solidity smart contracts can run on L2 exactly how they run on L1.\nSimilarly, off-chain code (ie. UIs and wallets), should be able to interact with L2 contracts with little more than an updated RPC endpoint.")]),e._v(" "),t("h2",{attrs:{id:"system-overview"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#system-overview"}},[e._v("#")]),e._v(" System Overview")]),e._v(" "),t("p",[e._v("The smart contracts in the Rollux protocol can be separated into a few key components. We will discuss each component in more detail below.")]),e._v(" "),t("ul",[t("li",[t("strong",[t("a",{attrs:{href:"#chain-contracts"}},[e._v("Chain:")])]),e._v(" Contracts on layer-1, which hold the ordering of layer-2 transactions, and commitments to the associated layer-2 state roots.")]),e._v(" "),t("li",[t("strong",[t("a",{attrs:{href:"#verification"}},[e._v("Verification:")])]),e._v(" Contracts on layer-1 which implement the process for challenging a transaction result.")]),e._v(" "),t("li",[t("strong",[t("a",{attrs:{href:"#bridge-contracts"}},[e._v("Bridge:")])]),e._v(" Contracts which facilitate message passing between layer-1 and layer-2.")]),e._v(" "),t("li",[t("strong",[t("a",{attrs:{href:"#predeployed-contracts"}},[e._v("Predeploys:")])]),e._v(" A set of essential contracts which are deployed and available in the genesis state of the system. These contracts are similar to Ethereum's precompiles, however they are written in Solidity, and can be found at addresses prefixed with 0x42.")])]),e._v(" "),t("h2",{attrs:{id:"chain-contracts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#chain-contracts"}},[e._v("#")]),e._v(" Chain Contracts")]),e._v(" "),t("p",[e._v("The Chain is composed of a set of contracts running on the Syscoin mainnet. These contracts store ordered\nlists of:")]),e._v(" "),t("ol",[t("li",[e._v("An "),t("em",[e._v("ordered")]),e._v(" list of all transactions applied to the L2 state.")]),e._v(" "),t("li",[e._v("The proposed state root which would result from the application of each transaction.")]),e._v(" "),t("li",[e._v("Transactions sent from L1 to L2, which are pending inclusion in the ordered list.")])]),e._v(" "),t("p",[e._v("The chain is composed of the following concrete contracts:\n")]),e._v(" "),t("h3",{attrs:{id:"batchinbox-ctc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#batchinbox-ctc"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/SYS-Labs/rollux/blob/develop/packages/contracts-bedrock/contracts/L1/BatchInbox.sol",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("BatchInbox")]),t("OutboundLink")],1),e._v(" (CTC)")]),e._v(" "),t("p",[e._v("The Canonical Transaction Chain (CTC) contract is an append-only log of transactions which must be applied to the OVM state. It defines the ordering of transactions by writing them to the "),t("code",[e._v("CTC:batches")]),e._v(" instance of the Chain Storage Container. The CTC also allows any account to "),t("code",[e._v("enqueue()")]),e._v(" an L2 transaction, which the Sequencer must  eventually append to the rollup state.")]),e._v(" "),t("h3",{attrs:{id:"statecommitmentchain-scc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#statecommitmentchain-scc"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/sys-labs/rollux/blob/master/packages/contracts/contracts/L1/rollup/StateCommitmentChain.sol",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("StateCommitmentChain")]),t("OutboundLink")],1),e._v(" (SCC)")]),e._v(" "),t("p",[e._v("The State Commitment Chain (SCC) contract contains a list of proposed state roots which Proposers assert to be a result of each transaction in the Canonical Transaction Chain (CTC). Elements here have a 1:1 correspondence with transactions in the CTC, and should be the unique state root calculated off-chain by applying the canonical transactions one by one.")]),e._v(" "),t("h3",{attrs:{id:"chainstoragecontainer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#chainstoragecontainer"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/sys-labs/rollux/blob/master/packages/contracts/contracts/L1/rollup/ChainStorageContainer.sol",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("ChainStorageContainer")]),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v('Provides reusable storage in the form of a "Ring Buffer" data structure, which will overwrite storage slots that are no longer needed. There are three Chain Storage Containers deployed, two are controlled by the CTC, one by the SCC.')]),e._v(" "),t("h2",{attrs:{id:"verification"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#verification"}},[e._v("#")]),e._v(" Verification")]),e._v(" "),t("p",[e._v("In the previous section, we mentioned that the Chain includes a list of the "),t("em",[e._v("proposed")]),e._v(" state roots\nresulting from each transaction. Here we explain a bit more about how these proposals happen, and how\nwe come to trust them.")]),e._v(" "),t("p",[e._v("In brief: If a proposed state root is not the correct result of executing a transaction, then a Verifier (which is anyone running a Rollux 'full node') can initiate a transaction result challenge. If the transaction result is successfully proven to be incorrect, the Verifier will receive a reward taken from funds which a Sequencer must put up as a bond.")]),e._v(" "),t("p",[e._v("::: Notice\nThis system is still being written, so these details are likely to\nchange\n:::")]),e._v(" "),t("h3",{attrs:{id:"bondmanager"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bondmanager"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/sys-labs/rollux/blob/master/packages/contracts/contracts/L1/verification/BondManager.sol",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("BondManager")]),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("The Bond Manager contract handles deposits in the form of an ERC20 token from bonded Proposers. It also handles the accounting of gas costs spent by a Verifier during the course of a challenge. In the event of a successful challenge, the faulty Proposer's bond is slashed, and the Verifier's gas costs are refunded.")]),e._v(" "),t("h2",{attrs:{id:"bridge-contracts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bridge-contracts"}},[e._v("#")]),e._v(" Bridge Contracts")]),e._v(" "),t("p",[e._v("The Bridge contracts implement the functionality required to pass messages between layer 1 and layer 2.  "),t("RouterLink",{attrs:{to:"/docs/developers/bridge/messaging.html"}},[e._v("You can read an overview\nhere")])],1),e._v(" "),t("p",[e._v("The Bridge is composed of the following concrete contracts:")]),e._v(" "),t("h3",{attrs:{id:"l1crossdomainmessenger"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#l1crossdomainmessenger"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/sys-labs/rollux/blob/master/packages/contracts/contracts/L1/messaging/L1CrossDomainMessenger.sol",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("L1CrossDomainMessenger")]),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("The L1 Cross Domain Messenger (L1xDM) contract sends messages from L1 to L2, and relays messages from L2 onto L1. In the event that a message sent from L1 to L2 is rejected for exceeding the L2 epoch gas limit, it can be resubmitted via this contract's replay function.")]),e._v(" "),t("h3",{attrs:{id:"l2crossdomainmessenger"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#l2crossdomainmessenger"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/sys-labs/rollux/blob/master/packages/contracts/contracts/L2/messaging/L2CrossDomainMessenger.sol",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("L2CrossDomainMessenger")]),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("The L2 Cross Domain Messenger (L2xDM) contract sends messages from L2 to L1, and is the entry point for L2 messages sent via the L1 Cross Domain Messenger.")]),e._v(" "),t("h2",{attrs:{id:"the-standard-bridge"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#the-standard-bridge"}},[e._v("#")]),e._v(" The Standard Bridge")]),e._v(" "),t("p",[e._v('One common case of message passing is "transferring" either ERC-20\ntokens or SYS between L1 and Rollux. To deposit tokens\ninto Rollux, the bridge locks them on L1 and mints equivalent\ntokens in Rollux. To withdraw tokens, the bridge burns the\nRollux tokens and releases the locked L1 tokens. '),t("RouterLink",{attrs:{to:"/docs/developers/bridge/standard-bridge.html"}},[e._v("More details\nare here")])],1),e._v(" "),t("h3",{attrs:{id:"l1standardbridge"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#l1standardbridge"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/sys-labs/rollux/blob/master/packages/contracts/contracts/L1/messaging/L1StandardBridge.sol",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("L1StandardBridge")]),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("The L1 part of the Standard Bridge. Responsible for finalising withdrawals from L2 and initiating deposits into L2 of ETH and compliant ERC20s.")]),e._v(" "),t("h3",{attrs:{id:"l2standardbridge"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#l2standardbridge"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/sys-labs/rollux/blob/master/packages/contracts/contracts/L2/messaging/L2StandardBridge.sol",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("L2StandardBridge")]),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("The L2 part of the Standard Bridge. Responsible for finalising deposits from L1 and initiating withdrawals from L2 of ETH and compliant ERC20s.")]),e._v(" "),t("h3",{attrs:{id:"l2standardtokenfactory"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#l2standardtokenfactory"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/sys-labs/rollux/blob/master/packages/contracts/contracts/L2/messaging/L2StandardTokenFactory.sol",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("L2StandardTokenFactory")]),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("Factory contract for creating standard L2 token representations of L1 ERC20s compatible with and working on the standard bridge.\n"),t("a",{attrs:{href:"https://github.com/sys-labs/rollux-tutorial/tree/main/standard-bridge-standard-token",target:"_blank",rel:"noopener noreferrer"}},[e._v("See here for more information"),t("OutboundLink")],1),e._v(".")]),e._v(" "),t("h2",{attrs:{id:"predeployed-contracts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#predeployed-contracts"}},[e._v("#")]),e._v(" Predeployed Contracts")]),e._v(" "),t("p",[e._v('"Predeploys" are a set of essential L2 contracts which are deployed and available in the genesis state of the system. These contracts are similar to Ethereum\'s precompiles, however they are written in Solidity and can be found in the OVM at addresses prefixed with 0x42.')]),e._v(" "),t("p",[e._v("Looking up predeploys is available in the Solidity library "),t("a",{attrs:{href:"https://github.com/sys-labs/rollux/blob/master/packages/contracts/contracts/libraries/constants/Lib_PredeployAddresses.sol",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("Lib_PredeployAddresses")]),t("OutboundLink")],1),e._v(" as well as in the "),t("code",[e._v("@eth-optimism/contracts")]),e._v(" package as "),t("code",[e._v("predeploys")]),e._v(" export.")]),e._v(" "),t("p",[e._v("The following concrete contracts are predeployed:")]),e._v(" "),t("h3",{attrs:{id:"ovm-l1messagesender"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ovm-l1messagesender"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/sys-labs/rollux/blob/master/packages/contracts/contracts/L2/predeploys/iOVM_L1MessageSender.sol",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("OVM_L1MessageSender")]),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("The L1MessageSender is a predeployed contract running on L2.\nDuring the execution of cross domain transaction from L1 to L2, it returns the address of the L1 account (either an EOA or contract) which sent the message to L2 via the Canonical Transaction Chain's "),t("code",[e._v("enqueue()")]),e._v(" function.")]),e._v(" "),t("p",[e._v("Note that this contract is not written in Solidity. However,\nthe interface linked above still works as if it were. In this way\nit is similar to the EVM's predeploys.")]),e._v(" "),t("h3",{attrs:{id:"ovm-l2tol1messagepasser"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ovm-l2tol1messagepasser"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/sys-labs/rollux/blob/master/packages/contracts/contracts/L2/predeploys/OVM_L2ToL1MessagePasser.sol",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("OVM_L2ToL1MessagePasser")]),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("The L2 to L1 Message Passer is a utility contract which facilitate an L1 proof of a message on L2. The L1 Cross Domain Messenger performs this proof in its _verifyStorageProof function, which verifies the existence of the transaction hash in this  contract's "),t("code",[e._v("sentMessages")]),e._v(" mapping.")]),e._v(" "),t("h3",{attrs:{id:"ovm-sequencerfeevault"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ovm-sequencerfeevault"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/sys-labs/rollux/blob/master/packages/contracts/contracts/L2/predeploys/OVM_SequencerFeeVault.sol",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("OVM_SequencerFeeVault")]),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("This contract holds fees paid to the sequencer until there is enough to\njustify the transaction cost of sending them to L1 where they are used to\npay for L1 transaction costs (mostly the cost of publishing all L2 transaction\ndata as CALLDATA on L1).")]),e._v(" "),t("h3",{attrs:{id:"lib-addressmanager"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lib-addressmanager"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/sys-labs/rollux/blob/master/packages/contracts/contracts/libraries/resolver/Lib_AddressManager.sol",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("Lib_AddressManager")]),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("This is a library that stores the mappings between names and their addresses.\nIt is used by "),t("code",[e._v("L1CrossDomainMessenger")]),e._v(".")])])}),[],!1,null,null,null);t.default=r.exports}}]);